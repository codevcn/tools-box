import sys
import math
from PySide6.QtCore import Qt, QTimer, QSize
from PySide6.QtGui import QPainter, QBrush, QColor, QPaintEvent, QShowEvent, QHideEvent
from PySide6.QtWidgets import QApplication, QWidget, QVBoxLayout, QPushButton, QLabel
from configs.configs import ThemeColors


class LoadingDots(QWidget):
    def __init__(
        self,
        parent: QWidget | None = None,
        dot_count=3,
        dot_size=12,
        color=ThemeColors.MAIN,
        spacing=8,
        speed_factor=1.0,
        max_scale=1.4,  # <--- MỚI: Mức scale tối đa (1.4 = 140%)
        stagger_delay=100,  # <--- MỚI: Thời gian đợi giữa các dot (ms) (100ms = 0.1s)
    ):
        super().__init__(parent)

        # --- Properties ---
        self._dot_count = dot_count
        self._dot_size = dot_size
        self._color = QColor(color)
        self._spacing = spacing

        self._max_scale = max_scale  # Lưu mức scale user muốn
        self._stagger_delay = stagger_delay  # Lưu thời gian delay (ms)

        # Speed config
        self._base_step = 0.15  # Bước nhảy cơ bản mỗi 16ms
        self._speed_factor = speed_factor

        # Tính toán độ lệch pha dựa trên thời gian delay (ms)
        self._phase_shift = 0.0
        self._recalc_phase_shift()

        # --- Animation State ---
        self._counter = 0.0
        self._is_running = False

        self._timer = QTimer(self)
        self._timer.setInterval(16)  # ~60 FPS (16ms per frame)
        self._timer.timeout.connect(self._on_timeout)

        self.setSizePolicy(
            self.sizePolicy().Policy.Fixed, self.sizePolicy().Policy.Fixed
        )
        self.updateGeometry()

    def _recalc_phase_shift(self):
        """
        Chuyển đổi thời gian delay (ms) thành độ lệch pha (radian)
        dựa trên tốc độ hiện tại.

        Công thức:
        - Mỗi frame (16ms) counter tăng: (base_step * speed_factor)
        - Số frame trong 'delay_ms': delay_ms / 16
        - Tổng counter cần lệch: (Counter/Frame) * (Số Frame)
        """
        step_per_frame = self._base_step * self._speed_factor
        frames_needed = self._stagger_delay / 16.0
        self._phase_shift = step_per_frame * frames_needed

    # --- Public API ---
    def start(self):
        self._is_running = True
        if self.isVisible():
            self._timer.start()
        self.update()

    def stop(self):
        self._is_running = False
        self._timer.stop()
        self.update()

    def update_properties(
        self,
        max_scale: float | None = None,
        stagger_delay: int | None = None,
        speed_factor: float | None = None,
        color: str | None = None,
        dot_size: int | None = None,
    ):
        """Hàm cập nhật thông số runtime."""
        need_recalc_phase = False

        if color is not None:
            self._color = QColor(color)

        if max_scale is not None:
            self._max_scale = max_scale
            self.updateGeometry()  # Scale đổi thì size widget phải đổi

        if speed_factor is not None:
            self._speed_factor = speed_factor
            need_recalc_phase = True

        if stagger_delay is not None:
            self._stagger_delay = stagger_delay
            need_recalc_phase = True

        if need_recalc_phase:
            self._recalc_phase_shift()

        if dot_size is not None:
            self._dot_size = dot_size
            self.updateGeometry()  # Kích thước dot đổi thì size widget phải đổi

        self.update()

    # --- Event Handlers ---
    def showEvent(self, event: QShowEvent):
        super().showEvent(event)
        if self._is_running:
            self._timer.start()

    def hideEvent(self, event: QHideEvent):
        super().hideEvent(event)
        self._timer.stop()

    def _on_timeout(self):
        self._counter += self._base_step * self._speed_factor
        self.update()

    # --- Geometry ---
    def sizeHint(self):
        max_dot_w = self._dot_size * self._max_scale
        total_width = (max_dot_w * self._dot_count) + (
            self._spacing * (self._dot_count - 1)
        )
        # Thêm padding an toàn
        return QSize(int(total_width + 4), int(max_dot_w + 4))

    # --- Painting ---
    def paintEvent(self, event: QPaintEvent):
        painter = QPainter(self)
        painter.setRenderHint(QPainter.RenderHint.Antialiasing)
        painter.setBrush(QBrush(self._color))
        painter.setPen(Qt.PenStyle.NoPen)

        center_y = self.height() / 2
        max_dot_w = self._dot_size * self._max_scale

        for i in range(self._dot_count):
            scale_factor = 1.0

            if self._is_running:
                # Math: Dùng _phase_shift đã tính toán để tạo độ trễ chính xác
                # Sin wave chạy từ -1 đến 1
                wave = math.sin(self._counter - (i * self._phase_shift))

                # Normalize về 0 -> 1
                norm = (wave + 1) / 2

                # Áp dụng mức Max Scale user mong muốn
                scale_factor = 1.0 + (self._max_scale - 1.0) * norm

            current_size = self._dot_size * scale_factor

            # Vẽ từ tâm
            x_base = i * (max_dot_w + self._spacing)
            x_center_offset = (max_dot_w - current_size) / 2

            draw_x = x_base + x_center_offset
            draw_y = center_y - (current_size / 2)

            painter.drawEllipse(
                int(draw_x), int(draw_y), int(current_size), int(current_size)
            )
